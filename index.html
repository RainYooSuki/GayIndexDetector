<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gay指数检测器</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🌈</text></svg>">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <!-- 引入 Bootstrap Icons 用于 GitHub 图标 -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Roboto', sans-serif;
            /* --- 增强的动态背景 --- */
            background: linear-gradient(-45deg, #f0f4f8, #e6f7ff, #f5f0ff, #e8f5e9);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            /* --- 结束增强的背景 --- */
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            position: relative;
            overflow-x: hidden; /* 防止动画导致水平滚动 */
        }

        /* --- 增强的背景动画 --- */
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        /* --- 结束增强的背景动画 --- */

        /* --- 增强的语言切换按钮动画 --- */
        .language-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.85); /* 稍微提高不透明度以增强可见性 */
            border: none;
            border-radius: 16px; /* 稍微更圆润 */
            padding: 10px 18px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 100;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); /* 更平滑、更有弹性的过渡 */
            backdrop-filter: blur(5px); /* 微妙的毛玻璃效果 */
        }
        .language-toggle:hover {
            background: rgba(255, 255, 255, 1);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            transform: translateY(-3px) scale(1.05); /* 悬停时稍微放大 */
        }
        .language-toggle:active {
             transform: translateY(-1px) scale(0.98); /* 轻微的按下效果 */
        }
        /* --- 结束增强的语言切换 --- */

        /* --- 增强的 GitHub 链接动画 --- */
        .github-link {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: #333;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            z-index: 100;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); /* 更平滑、更有弹性的过渡 */
            backdrop-filter: blur(2px); /* 一致的毛玻璃效果 */
        }
        .github-link:hover {
            transform: translateY(-8px) scale(1.15); /* 更明显的提升和缩放 */
            background: #000;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }
        .github-link:active {
             transform: translateY(-4px) scale(1.08); /* 轻微的按下效果 */
        }
        .github-link .bi {
            color: white;
            font-size: 24px;
            transition: transform 0.3s ease; /* 图标旋转效果 */
        }
        .github-link:hover .bi {
            transform: rotate(30deg); /* 悬停时旋转图标 */
        }
        /* --- 结束增强的 GitHub 链接 --- */

        /* --- 增强的主容器动画 --- */
        .container {
            width: 100%;
            max-width: 500px;
            background: rgba(255, 255, 255, 0.92); /* 稍微透明 */
            border-radius: 28px; /* 稍微更圆润 */
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            opacity: 0;
            transform: translateY(30px);
            animation: fadeInUp 0.8s cubic-bezier(0.23, 1, 0.32, 1) forwards; /* 入场动画 */
            backdrop-filter: blur(10px); /* 毛玻璃效果 */
            border: 1px solid rgba(255, 255, 255, 0.5); /* 微妙的边框 */
        }
        @keyframes fadeInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        /* --- 结束增强的容器 --- */

        .header {
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            color: white;
            padding: 35px 24px; /* 稍微增加内边距 */
            text-align: center;
        }
        .header h1 {
            font-weight: 500;
            font-size: 28px;
            margin-bottom: 8px;
        }
        .header p {
            font-weight: 300;
            opacity: 0.9;
            font-size: 16px;
        }

        .content {
            padding: 35px; /* 稍微增加内边距 */
        }

        .input-group {
            margin-bottom: 30px;
        }
        .input-group label {
            display: block;
            margin-bottom: 12px;
            font-weight: 500;
            color: #333;
            font-size: 16px;
        }

        /* --- 增强的输入框动画 --- */
        .input-wrapper {
            position: relative;
        }
        .input-wrapper input {
            width: 100%;
            padding: 16px 20px;
            border: 2px solid #e0e0e0;
            border-radius: 16px;
            font-size: 16px;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1); /* 更平滑的默认过渡 */
            outline: none;
            background-color: rgba(255, 255, 255, 0.7); /* 稍微透明的背景 */
        }
        .input-wrapper input:focus {
            border-color: #6a11cb;
            box-shadow: 0 0 0 4px rgba(106, 17, 203, 0.2); /* 更柔和的焦点光晕 */
            background-color: rgba(255, 255, 255, 1); /* 焦点时为纯色背景 */
        }
        /* 焦点时添加微妙的脉冲动画 */
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(106, 17, 203, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(106, 17, 203, 0); }
            100% { box-shadow: 0 0 0 0 rgba(106, 17, 203, 0); }
        }
        .input-wrapper input:focus {
            animation: pulse 1s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        .input-wrapper .material-icons {
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            color: #757575;
            transition: color 0.3s ease, transform 0.3s ease; /* 图标过渡 */
        }
        .input-wrapper input:focus + .material-icons {
            color: #6a11cb;
            transform: translateY(-50%) scale(1.2); /* 焦点时稍微放大图标 */
        }
        /* --- 结束增强的输入框 --- */

        /* --- 增强的按钮动画 --- */
        .btn {
            display: block;
            width: 100%;
            padding: 16px;
            background: linear-gradient(to right, #6a11cb, #2575fc);
            color: white;
            border: none;
            border-radius: 16px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); /* 更平滑、更有弹性 */
            box-shadow: 0 4px 15px rgba(37, 117, 252, 0.3);
            position: relative;
            overflow: hidden;
        }
        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        .btn:hover {
            transform: translateY(-3px) scale(1.02); /* 提升和轻微缩放 */
            box-shadow: 0 7px 20px rgba(37, 117, 252, 0.4);
        }
        .btn:hover::before {
            width: 300px;
            height: 300px;
        }
        .btn:active {
            transform: translateY(-1px) scale(0.98); /* 轻微的按下效果 */
        }
        /* --- 结束增强的按钮 --- */

        /* --- 修改结果容器动画，实现动态高度调整 --- */
        .result-container {
            /* --- 关键：初始状态不占用布局空间 --- */
            opacity: 0;
            max-height: 0; /* 初始最大高度为0 */
            padding: 0 35px; /* 左右padding保留，上下padding设为0 */
            margin-top: 0; /* 顶部外边距设为0 */
            margin-bottom: 0; /* 底部外边距设为0 */
            overflow: hidden; /* 隐藏溢出内容 */
            /* --- 关键：过渡动画 --- */
            transition: opacity 0.5s ease-out 0.2s,
                        max-height 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0.2s,
                        padding 0.5s ease-out 0.2s,
                        margin 0.5s ease-out 0.2s;
        }

        /* --- 定义显示状态的类 --- */
        .result-container.show {
            opacity: 1;
            max-height: 800px; /* 设置一个足够大的值，确保内容能完全展开 */
            padding: 35px; /* 恢复正常的上下内边距 */
            margin-top: 30px; /* 恢复顶部外边距 */
            margin-bottom: 30px; /* 恢复底部外边距 */
        }
        /* --- 结束修改的结果容器 --- */

        .result-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 16px;
        }
        .result-header h2 {
            font-weight: 500;
            font-size: 20px;
            color: #333;
        }
        .score {
            font-weight: 700;
            font-size: 24px;
            color: #6a11cb;
            /* --- 增强的分数动画 --- */
            transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275), color 0.3s ease;
        }
        .score.updated {
             animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popIn {
            0% { transform: scale(0.8); opacity: 0; }
            70% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }
        /* --- 结束增强的分数 --- */

        .progress-container {
            height: 24px;
            background: #e0e0e0;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 24px;
            position: relative;
        }
        /* --- 增强的进度条动画 --- */
        .progress-bar {
            height: 100%;
            background: linear-gradient(to right, #6a11cb, #2575fc);
            border-radius: 12px;
            width: 0%;
            /* 为进度使用更动态的缓动函数 */
            transition: width 2s cubic-bezier(0.22, 0.61, 0.36, 1); /* 更长的持续时间，更平滑的曲线 */
            position: relative;
        }
        /* 为进度条添加微妙的光泽效果 */
        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            animation: shine 2s infinite;
        }
        @keyframes shine {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        /* --- 结束增强的进度条 --- */

        .progress-labels {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #757575;
            margin-top: 8px;
        }

        /* --- 修改评价和彩虹区域，使其能动态调整容器大小 --- */
        .evaluation, .rainbow {
            background: #f5f7ff; /* 给 rainbow 也加上背景色保持一致 */
            border-radius: 16px;
            padding: 20px;
            text-align: center;
            margin-top: 20px; /* 统一使用 margin-top 控制间距 */
            /* --- 关键：初始状态不占用空间 --- */
            opacity: 0;
            transform: scaleY(0.8); /* 垂直压缩 */
            height: 0;
            padding-top: 0;
            padding-bottom: 0;
            margin-top: 0;
            margin-bottom: 0;
            overflow: hidden;
            /* --- 关键：过渡动画 --- */
            /* 使用不同的延迟让 Evaluation 先出现，Rainbow 后出现 */
            transition: opacity 0.4s ease-out,
                        transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1),
                        height 0.4s ease-out,
                        padding 0.4s ease-out,
                        margin 0.4s ease-out;
        }

        /* --- 为 rainbow 单独设置样式，因为它初始是 display: none --- */
        .rainbow {
            background: linear-gradient(90deg, #ff0000, #ff8000, #ffff00, #80ff00, #00ff00, #00ff80, #00ffff, #0080ff, #0000ff, #8000ff, #ff00ff, #ff0080);
            background-size: 1200% 100%;
            animation: rainbow 15s linear infinite;
            color: white;
            font-weight: 500;
            display: none; /* 初始隐藏 */
            /* 单独的过渡，用于显示/隐藏 */
            transition: opacity 0.5s ease-out 0.2s, /* 延迟淡入 */
                        transform 0.5s cubic-bezier(0.25, 0.8, 0.25, 1) 0.2s,
                        height 0.5s ease-out 0.2s,
                        padding 0.5s ease-out 0.2s,
                        margin 0.5s ease-out 0.2s,
                        display 0.5s ease-out; /* 控制 display 变化 */
        }
        @keyframes rainbow {
            0% { background-position: 0% 50%; }
            100% { background-position: 100% 50%; }
        }

        /* --- 显示状态的类 --- */
        .evaluation.show, .rainbow.show {
            opacity: 1;
            transform: scaleY(1); /* 恢复原状 */
            height: auto; /* 恢复自动高度 */
            padding: 20px; /* 恢复内边距 */
            margin-top: 20px; /* 恢复外边距 */
            overflow: visible;
        }
        /* 对于 rainbow，show 时需要 display: block */
        .rainbow.show {
            display: block;
        }

        /* --- 评价区域内部样式微调 --- */
        .evaluation h3 {
            font-weight: 500;
            margin-bottom: 12px;
            color: #333;
            /* 确保标题和段落也有过渡效果，使其随容器一起出现 */
            transition: inherit;
        }
        .evaluation p {
            color: #666;
            line-height: 1.6;
            transition: inherit;
        }
        /* --- 结束修改评价和彩虹区域 --- */

        .stage-indicator {
            display: flex;
            justify-content: space-between;
            margin-top: 16px;
        }
        /* --- 增强的阶段指示器动画 --- */
        .stage {
            width: 18%;
            text-align: center;
            padding: 8px 0;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1); /* 更平滑的过渡 */
            background-color: #eeeeee; /* 默认背景 */
            color: #757575; /* 默认文本颜色 */
            transform: scale(0.9);
        }
        .stage.active {
            background: linear-gradient(135deg, #6a11cb, #2575fc); /* 渐变背景 */
            color: white;
            font-weight: bold;
            transform: scale(1.05); /* 激活时稍微放大 */
            box-shadow: 0 4px 10px rgba(106, 17, 203, 0.3); /* 为激活阶段添加阴影 */
        }
        /* --- 结束增强的阶段 --- */

        @media (max-width: 600px) {
            .container {
                border-radius: 24px; /* 为小屏幕调整 */
            }
            .header {
                padding: 28px 20px; /* 调整内边距 */
            }
            .content {
                padding: 28px; /* 调整内边距 */
            }
            .language-toggle {
                top: 15px;
                right: 15px;
                padding: 8px 16px;
                border-radius: 12px; /* 调整边框半径 */
            }
            .github-link {
                bottom: 15px;
                right: 15px;
                width: 45px;
                height: 45px;
            }
        }
    </style>
</head>
<body>
    <!-- 修改后的中英文切换按钮 -->
    <button id="languageToggle" class="language-toggle">EN</button>
    <!-- 使用新的 GitHub 图标 -->
    <a href="https://github.com/RainYooSuki/GayIndexDetector" target="_blank" class="github-link">
        <i class="bi bi-github"></i>
    </a>
    <div class="container">
        <div class="header">
            <h1 id="pageTitle">Gay指数检测器</h1>
            <p id="pageSubtitle">输入名字，看看你的Gay指数有多高</p>
        </div>
        <div class="content">
            <div class="input-group">
                <label for="userName" id="inputLabel">请输入你的名字</label>
                <div class="input-wrapper">
                    <input type="text" id="userName" placeholder="">
                    <span class="material-icons">person</span>
                </div>
            </div>
            <button id="calculateBtn" class="btn">检测我的Gay指数</button>
            <div class="result-container" id="resultContainer">
                <div class="result-header">
                    <h2 id="resultTitle">检测结果</h2>
                    <div class="score" id="scoreDisplay">0</div>
                </div>
                <div class="progress-container">
                    <div class="progress-bar" id="progressBar"></div>
                </div>
                <div class="progress-labels">
                    <span id="label0">0 (直男)</span>
                    <span>20</span>
                    <span>40</span>
                    <span>60</span>
                    <span>80</span>
                    <span id="label100">100 (终极Gay)</span>
                </div>
                <div class="stage-indicator">
                    <div class="stage" data-stage="0">0-20</div>
                    <div class="stage" data-stage="1">21-40</div>
                    <div class="stage" data-stage="2">41-60</div>
                    <div class="stage" data-stage="3">61-80</div>
                    <div class="stage" data-stage="4">81-100</div>
                </div>
                <div class="evaluation">
                    <h3 id="evaluationTitle">评价</h3>
                    <p id="evaluationText">请输入名字开始检测</p>
                </div>
                <div class="rainbow" id="rainbowMessage">
                    恭喜你解锁了终极Gay模式！🌈
                </div>
            </div>
        </div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // 语言切换相关元素
            const languageToggle = document.getElementById('languageToggle');
            const pageTitle = document.getElementById('pageTitle');
            const pageSubtitle = document.getElementById('pageSubtitle');
            const inputLabel = document.getElementById('inputLabel');
            const calculateBtn = document.getElementById('calculateBtn');
            const resultTitle = document.getElementById('resultTitle');
            const label0 = document.getElementById('label0');
            const label100 = document.getElementById('label100');
            const evaluationTitle = document.getElementById('evaluationTitle');
            const evaluationText = document.getElementById('evaluationText');
            const rainbowMessage = document.getElementById('rainbowMessage');
            // 用户输入相关元素
            const userName = document.getElementById('userName');
            const resultContainer = document.getElementById('resultContainer');
            const scoreDisplay = document.getElementById('scoreDisplay');
            const progressBar = document.getElementById('progressBar');
            const stages = document.querySelectorAll('.stage');
            const evaluationDiv = document.querySelector('.evaluation'); // 添加引用
            // 当前语言状态 (0: 中文, 1: 英文)
            let currentLanguage = 0;
            // 语言文本映射
            const languageTexts = {
                pageTitle: ["Gay指数检测器", "Gay Index Detector"],
                pageSubtitle: ["输入名字，看看你的Gay指数有多高", "Enter your name to see how gay you are"],
                inputLabel: ["请输入你的名字", "Please enter your name"],
                calculateBtn: ["检测我的Gay指数", "Detect My Gay Index"],
                resultTitle: ["检测结果", "Detection Result"],
                label0: ["0 (直男)", "0 (Straight)"],
                label100: ["100 (终极Gay)", "100 (Ultimate Gay)"],
                evaluationTitle: ["评价", "Evaluation"],
                evaluationText: ["请输入名字开始检测", "Please enter your name to start detection"],
                rainbowMessage: ["恭喜你解锁了终极Gay模式！🌈", "Congratulations on unlocking Ultimate Gay mode! 🌈"],
                stage0: ["0-20", "0-20"],
                stage1: ["21-40", "21-40"],
                stage2: ["41-60", "41-60"],
                stage3: ["61-80", "61-80"],
                stage4: ["81-100", "81-100"]
            };
            // 阶段评价映射（中英文）
            const stageEvaluations = [
                { 
                    title: ["钢铁直男", "Steel Straight"],
                    text: [
                        "恭喜你！你的名字散发着纯正的直男气息，连风都为你吹偏了方向。",
                        "Congratulations! Your name radiates pure straight energy. Even the wind changes direction for you."
                    ]
                },
                { 
                    title: ["疑似Gay", "Suspected Gay"],
                    text: [
                        "你的名字透露出一丝不寻常的气息，建议检查一下衣橱里是不是混入了别人的衣服。",
                        "Your name reveals a hint of unusual energy. We suggest checking if someone else's clothes got mixed in your closet."
                    ]
                },
                { 
                    title: ["半糖Gay", "Half-Sugar Gay"],
                    text: [
                        "你的名字带有明显的Gay属性，但还处于可控制范围内。建议多喝热水，保持冷静。",
                        "Your name clearly has Gay attributes, but it's still within control. Drink more hot water and stay calm."
                    ]
                },
                { 
                    title: ["资深Gay", "Senior Gay"],
                    text: [
                        "哇哦！你的名字简直就是Gay界的标杆，建议申请吉尼斯世界纪录。",
                        "Wow! Your name is a benchmark in the Gay world. Consider applying for a Guinness World Record."
                    ]
                },
                { 
                    title: ["终极Gay", "Ultimate Gay"],
                    text: [
                        "天哪！你的名字充满了Gay的终极奥义，连彩虹都为你感到骄傲！",
                        "Oh my! Your name is filled with the ultimate Gay essence. Even the rainbow is proud of you!"
                    ]
                }
            ];
            // --- 新增：一个简单的基于字符串的“哈希”函数 ---
            // 目的：为相同的字符串产生相同的“伪随机”数，不同字符串产生不同的数
            function simpleHash(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char; // hash * 31 + char
                    hash = hash & hash; // 转换为 32 位整数
                }
                return Math.abs(hash); // 返回非负数
            }
            // 计算分数的函数（调整版，实现可正可负的长度因子和概率性范围映射）
            function calculateScore(name) {
                if (!name) return 0;
                let score = 0;
                let hasNonEnglishChar = false;
                // 检查是否包含非英文字符，并为每个非英文字符提供基础加分
                for (let char of name) {
                    const codePoint = char.codePointAt(0);
                    if (!((codePoint >= 65 && codePoint <= 90) || (codePoint >= 97 && codePoint <= 122))) {
                        hasNonEnglishChar = true;
                        score += 5; // 基础加分
                    }
                }
                // --- 修改：可正可负的长度因子 ---
                let lengthComponent = name.length * 4; // 基础长度分
                if (hasNonEnglishChar) {
                    lengthComponent *= 1.1; // 非英文字符长度分加成
                }
                // 决定长度因子正负：使用字符串哈希值的奇偶性
                const hashForSign = simpleHash(name);
                const isLengthPositive = (hashForSign % 2 === 0); // 偶数为正，奇数为负
                const lengthBonus = isLengthPositive ? lengthComponent : -lengthComponent * 0.5; // 负向影响减半
                score += Math.min(Math.abs(lengthBonus) * (isLengthPositive ? 1 : 0.5), 45); // 应用长度分，负向影响更小且有上限
                // 其他加分项保持不变或微调
                const vowels = name.match(/[aeiouAEIOU]/g);
                if (vowels) {
                    score += Math.min(vowels.length * 3, 25);
                }
                const specialChars = name.match(/[yYlLrRsS]/g);
                if (specialChars) {
                    score += Math.min(specialChars.length * 4, 18);
                }
                if (name.toLowerCase().includes('gay')) {
                    score += 25;
                }
                // --- 修改：基于内容的概率性范围映射 ---
                if (score <= 0) return 0; // 如果基础分非正，直接返回0
                // 1. 使用哈希值决定目标区间
                const hashForRange = simpleHash(name + "range"); // 使用不同种子避免冲突
                const rangeIndex = hashForRange % 5; // 0 to 4
                const ranges = [
                    { min: 0, max: 20 },
                    { min: 21, max: 40 },
                    { min: 41, max: 60 },
                    { min: 61, max: 80 },
                    { min: 81, max: 100 }
                ];
                const targetRange = ranges[rangeIndex];
                // 2. 将原始分数映射到目标区间
                // 首先，我们需要一个“参考分数”来决定如何映射。
                // 这里我们简单地使用 score 本身作为参考，但可以进行一些变换使其更平滑。
                // 例如，可以先对其进行对数压缩： refScore = Math.log10(score + 1) * 10;
                let refScore = Math.log10(score + 1) * 15; // 对原始得分进行压缩
                // 为了增加离散度，我们可以引入另一个基于哈希的扰动因子
                const hashForPerturbation = simpleHash(name + "perturb");
                const perturbationFactor = 0.9 + ((hashForPerturbation % 1000003) / 1000003) * 0.2; // 0.9 to 1.1
                refScore *= perturbationFactor;
                // 将 refScore (理论上可以是任意正数) 映射到 0-100 的总范围内，然后看它落在哪个部分
                // 一种方法是将其对 100 取模，但这可能不够平滑。
                // 更好的方法是使用 Sigmoid 函数或直接线性映射，但我们已经决定了目标区间。
                // 所以，我们将 refScore 映射到 0-1 的范围，然后映射到目标区间的具体分数。
                // 简化处理：将 refScore 通过一个函数压缩到 0-100，然后看它自然落在哪个区间
                // 但因为我们已经指定了目标区间，我们直接将 refScore 映射到该区间。
                // 为了使映射有意义，我们假设 refScore 有一个大致的范围（比如 0-50）
                // 我们可以将其裁剪并线性映射到目标区间
                const clampedRefScore = Math.min(Math.max(refScore, 0), 50); // 假设 refScore 通常在 0-50
                const mappedScore = targetRange.min + (clampedRefScore / 50) * (targetRange.max - targetRange.min);
                // 3. 为了进一步增加非英文名字的离散度，可以对包含非英文字符的名字施加额外的映射扰动
                let finalScore = mappedScore;
                if (hasNonEnglishChar) {
                     const hashForFinalTweak = simpleHash(name + "final");
                     const tweakFactor = 0.95 + ((hashForFinalTweak % 1000003) / 1000003) * 0.1; // 0.95 to 1.05
                     finalScore = mappedScore * tweakFactor;
                }
                // 4. 确保最终分数在 0-100 之间
                return Math.min(Math.max(Math.floor(finalScore), 0), 100);
            }
            // 切换语言函数
            function toggleLanguage() {
                currentLanguage = 1 - currentLanguage;
                // 更新按钮文本
                languageToggle.textContent = currentLanguage === 0 ? 'EN' : '中文';
                // 更新所有文本
                pageTitle.textContent = languageTexts.pageTitle[currentLanguage];
                pageSubtitle.textContent = languageTexts.pageSubtitle[currentLanguage];
                inputLabel.textContent = languageTexts.inputLabel[currentLanguage];
                calculateBtn.textContent = languageTexts.calculateBtn[currentLanguage];
                resultTitle.textContent = languageTexts.resultTitle[currentLanguage];
                label0.textContent = languageTexts.label0[currentLanguage];
                label100.textContent = languageTexts.label100[currentLanguage];
                evaluationTitle.textContent = languageTexts.evaluationTitle[currentLanguage];
                // 如果结果显示了，更新评价
                if (resultContainer.classList.contains('show')) { // 检查 'show' 类而不是 display 样式
                    const score = parseInt(scoreDisplay.textContent);
                    const stage = Math.floor(score / 20);
                    evaluationText.textContent = stageEvaluations[stage].text[currentLanguage];
                    evaluationTitle.textContent = stageEvaluations[stage].title[currentLanguage];
                } else {
                    evaluationText.textContent = languageTexts.evaluationText[currentLanguage];
                }
                // 更新阶段标签
                stages[0].textContent = languageTexts.stage0[currentLanguage];
                stages[1].textContent = languageTexts.stage1[currentLanguage];
                stages[2].textContent = languageTexts.stage2[currentLanguage];
                stages[3].textContent = languageTexts.stage3[currentLanguage];
                stages[4].textContent = languageTexts.stage4[currentLanguage];
                // 更新彩虹消息
                rainbowMessage.textContent = languageTexts.rainbowMessage[currentLanguage];
            }
            // 更新进度条和评价
            function updateDisplay(score) {
                // 更新分数显示动画
                scoreDisplay.classList.remove('updated');
                void scoreDisplay.offsetWidth; // 触发回流
                scoreDisplay.textContent = score;
                scoreDisplay.classList.add('updated');

                // 更新进度条
                progressBar.style.width = score + '%';

                // 确定阶段
                const stage = Math.floor(score / 20);

                // 更新评价 (带有延迟以实现更平滑的序列)
                setTimeout(() => {
                    evaluationTitle.textContent = stageEvaluations[stage].title[currentLanguage];
                    evaluationText.textContent = stageEvaluations[stage].text[currentLanguage];
                    evaluationDiv.classList.add('show'); // 触发评价淡入
                }, 300); // 稍微延迟评价文本更新

                // 更新阶段指示器
                stages.forEach((el, index) => {
                    if (index === stage) {
                        el.classList.add('active');
                    } else {
                        el.classList.remove('active');
                    }
                });

                // --- 修改：处理彩虹消息 (使用动画和动态高度) ---
                if (score >= 80) {
                   // 延迟显示彩虹消息，使其在评价之后出现
                   setTimeout(() => {
                       rainbowMessage.classList.add('show'); // 触发彩虹区域淡入、展开和 display 变化
                   }, 600); // 比评价动画稍晚一点
                } else {
                    // 如果分数不够，确保彩虹消息隐藏
                    rainbowMessage.classList.remove('show');
                }
                // --- 结束修改 ---
            }

            // 计算按钮点击事件
            calculateBtn.addEventListener('click', function() {
                const name = userName.value.trim();
                if (!name) {
                    alert(currentLanguage === 0 ? '请输入你的名字' : 'Please enter your name');
                    return;
                }
                // --- 修改：显示结果容器动画 ---
                // 移除之前的 show 类以重置动画
                resultContainer.classList.remove('show');
                // 触发重排 (reflow) 以确保移除类生效
                void resultContainer.offsetWidth;
                // 添加 show 类触发动画
                resultContainer.classList.add('show');
                // --- 结束修改 ---

                // 重置 previous elements for animation replay (如果之前有实现)
                // ... (重置分数、进度条、阶段指示器等的动画类) ...
                // 例如：
                scoreDisplay.classList.remove('updated');
                progressBar.style.width = '0%';
                stages.forEach(s => s.classList.remove('active'));
                evaluationDiv.classList.remove('show');
                rainbowMessage.classList.remove('show');

                // 计算分数 (使用新算法)
                const score = calculateScore(name);

                // 延迟更新以显示动画效果
                setTimeout(() => {
                    updateDisplay(score);
                }, 100); // 这个延迟可以与容器出现动画配合
            });

            // 回车键触发计算
            userName.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    calculateBtn.click();
                }
            });

            // 语言切换按钮事件
            languageToggle.addEventListener('click', toggleLanguage);
        });
    </script>
</body>
</html>